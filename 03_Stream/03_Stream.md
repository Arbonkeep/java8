# Stream
    1. 概述
        * Stream是java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找
          过滤和映射数据等操作。而Stream API是提供一种高效而且易于使用的处理数据的方式

        * 流是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列

        * stream的特点
            <1> Stream自己不会存储元素

            <2> Stream不会改变源对象，相反，它们会返回一个持有结果的新的stream
            
            <3> stream操作是延迟执行的。这意味着它们会等到需要结果的时候才执行

        * stream的操作三个步骤
            <1> 创建 Stream（一个数据源（如：数组、集合），获取一个流）

            <2> 中间操作（一个中间操作链），对数据源的数据进行处理

            <3> 终止操作（又称终端操作，一个终止操作，执行中间操作链，并产生结果）

    2. Stream的创建
        <1> 可以通过Collection系列集合提供的stream()(串行流)和paralleStream()(并行流)

        <2> 通过Arrays中的静态方法stream()来获取数组流

        <3> 通过Stream类中的静态方法 of()

        <4> 创建无限流
            * 迭代（Stream中的iterator方法）
            * 生成（Stream中的generate方法）

    3. Stream的中间操作
        <1> 筛选与切片
            * Stream的中间操作的相关概念
                * 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何处理
                而在终止操作时一次性全部处理，这就称为“惰性求值”

                * 内部迭代：迭代操作由Stream API 完成

                * 外部迭代：由我们自己循环迭代遍历完成的迭代

            * filter：接收Lambda，从流中排除某些元素

            * limit：截断流，使得元素不超过给定数量

            *　skip(n)：跳过元素，返回一个扔掉前n个元素的流。若流中元素不够n个，则返回一个空流。与limit(n)互补

            * distinct：筛选，通过流所生成元素的hashCOde()和equals()去除重复元素

        <2> 映射
            * map：接收Lambda，将元素转换成其他形式，或者提取信息。接收一个函数作为参数，该函数会被应用到每个函数
                    上，并且将其映射成一个新的元素

            * flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连成一个流

        <3> 排序
            * sorted()：自然排序(Comparable)

            * sorted(Comparator com)：定制排序(Comparator)    

    4. Stream的终止操作
        <1> 查找与匹配
            * allMatch：检查是否匹配所有元素

            * anyMatch：检查是否至少匹配一个元素

            * noneMatch：检查是否没有匹配所有元素

            * findFirst：返回第一个元素

            * findAny：返回当前流中任意元素

            * count：返回流中元素的总个数

            * max：返回流中最大值

            * min：返回流中最小值

        <2> 归约
            * reduce(T identity, BinaryOperator) / reduce(BinaryOperator)：可以将流中元素反复集合起来，得到一个值

        <3> 收集
            * collect；将流转换为其他形式。接收一个collection的实现，用于给Stream元素中做汇总的方法

            * 注意：Collector接口种方法的实现决定了如何对流执行收集（如：收集到set，list，hashSet）,但是Collectors实
                 用类提供了很多静态方法，可以方便的创建收集器实例

    5. 并行流与顺序流
        <1> 概述
            * 并行流：就是把内容分成多个数据块，并用不同的县城后分别处理每个数据块的流

            * java8中将并行流进行了优化，我们可以很容易的对数据进行并行操作。Stream API可以声明性地通过parallel()和
            sequential()在并行流与顺序流之间进行切换

        <2> Fork/Join框架
            * 概念：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务(拆到不可拆分)，再将一个个的小任务运算
                    的结果进行join汇总
            
            * 特点：运行效率高（尤其在数据很大的情况下）

            * fork/join框架与传统线程池的区别
                * 采用“工作窃取”模式(working-stealing):
                    * 当执行新的任务时，它会将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的
                      队列中偷一个任务并把它放到自己的队列当中
                    
                    * 在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续执行，那么该线程就会处于阻塞状态
                      而在fork/join框架中，如果某个子问题由于等待另一个子问题的完成而无法继续执行，那么处理该子问题的
                      线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程的等待时间，提高了性能

            


                
            
        




    


        
